using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations.Schema;
using System.Linq;
using System.Text;
using BulkWriter.Internal;
using System.Threading.Tasks;
using Xunit;

namespace BulkWriter.Tests
{
    [Collection(nameof(DbContainerFixture))]
    public class AsyncEnumerableDataReaderTests : IAsyncLifetime
    {
        private readonly string _connectionString;

        private readonly string _tableName = nameof(MyTestClass);
        private readonly string _customOrderTableName = nameof(MyCustomOrderTestClass);

        private readonly IAsyncEnumerable<MyTestClass> _enumerable;
        private readonly AsyncEnumerableDataReader<MyTestClass> _dataReader;

        private readonly IAsyncEnumerable<MyCustomOrderTestClass> _customOrderEnumerable;
        private readonly AsyncEnumerableDataReader<MyCustomOrderTestClass> _customOrderDataReader;
        
        private readonly DbContainerFixture _fixture;

        public AsyncEnumerableDataReaderTests(DbContainerFixture fixture)
        {
            _fixture = fixture;
            _connectionString = fixture.TestConnectionString;

            //
            // Setup for testing default mapping using the source entity's property positions as the ordinals.
            //

            _enumerable = new[] { new MyTestClass() }.ToAsyncEnumerable();

            _fixture.ExecuteNonQuery(_connectionString, $"DROP TABLE IF EXISTS [dbo].[{_tableName}]");

            _fixture.ExecuteNonQuery(_connectionString,
                "CREATE TABLE [dbo].[" + _tableName + "](" +
                "[Id] [int] IDENTITY(1,1) NOT NULL," +
                "[Name] [nvarchar](50) NULL," +
                "[Data] [varbinary](max) NULL," +
                "CONSTRAINT [PK_" + _tableName + "] PRIMARY KEY CLUSTERED ([Id] ASC)" +
                ")");
            
            var propertyMappings = typeof(MyTestClass).BuildMappings();

            _dataReader = new AsyncEnumerableDataReader<MyTestClass>(_enumerable, propertyMappings);


            //
            // Setup for testing custom mapping using [Column(Order = ...)] to specify ordinals on the source
            //   entity. This is useful when the layout of the properties on the source entity doesn't match
            //   the column ordinals in the database table (e.g., tables generated by EF Core <= 2.0, which
            //   seems to create the columns by ordering the property names alphabetically).
            //

            _customOrderEnumerable = new[] { new MyCustomOrderTestClass() }.ToAsyncEnumerable();

            _fixture.ExecuteNonQuery(_connectionString, $"DROP TABLE IF EXISTS [dbo].[{_customOrderTableName}]");

            _fixture.ExecuteNonQuery(_connectionString,
                "CREATE TABLE [dbo].[" + _customOrderTableName + "](" +
                "[Id] [int] IDENTITY(1,1) NOT NULL," +
                "[FirstName] [nvarchar](50) NULL," +
                "[MiddleName] [nvarchar](50) NULL," +
                "[LastName] [nvarchar](50) NULL," +
                "CONSTRAINT [PK_" + _customOrderTableName + "] PRIMARY KEY CLUSTERED ([Id] ASC)" +
                ")");

            var customOrderPropertyMappings = typeof(MyCustomOrderTestClass).BuildMappings();

            _customOrderDataReader = new AsyncEnumerableDataReader<MyCustomOrderTestClass>(_customOrderEnumerable, customOrderPropertyMappings);
        }

        [Fact]
        public async Task Read_Advances_Enumerable()
        {
            Assert.Same(await _enumerable.ElementAtAsync(0), _dataReader.Current);
        }

        [Fact]
        public void GetOrdinal_Returns_Correct_Value()
        {
            // Use source entity property names to lookup the destination ordinals.
            // Here, the destination ordinal is the default positional ordinal from each property on
            //   the source entity. There is no custom mapping from ColumnAttributes.
            Assert.Equal(0, _dataReader.GetOrdinal(nameof(MyTestClass.Id)));
            Assert.Equal(1, _dataReader.GetOrdinal(nameof(MyTestClass.Name)));
            Assert.Equal(2, _dataReader.GetOrdinal(nameof(MyTestClass.Data)));
        }

        [Fact]
        public void GetOrdinal_Returns_Correct_Value_With_Custom_Order()
        {
            // Use source entity property names to lookup the destination ordinals.
            // Here, GetOrdinal returns the destination (i.e., database column) ordinal as defined in 
            //   the ColumnAttributes declared on the source entity's properties.
            Assert.Equal(0, _customOrderDataReader.GetOrdinal(nameof(MyCustomOrderTestClass.Id)));
            Assert.Equal(4, _customOrderDataReader.GetOrdinal(nameof(MyCustomOrderTestClass.FirstName)));
            Assert.Equal(1, _customOrderDataReader.GetOrdinal(nameof(MyCustomOrderTestClass.MiddleName)));
            Assert.Equal(2, _customOrderDataReader.GetOrdinal(nameof(MyCustomOrderTestClass.LastName)));
            Assert.Equal(3, _customOrderDataReader.GetOrdinal(nameof(MyCustomOrderTestClass.Data)));
        }

        [Fact]
        public void GetOrdinal_Throws_For_Invalid_Name()
        {
            Assert.Throws<InvalidOperationException>(() =>
            {
                Assert.Equal(1, _dataReader.GetOrdinal("ABC123XYZ_foobar_bad_name"));
            });
        }

        [Fact]
        public void GetOrdinal_Throws_For_Invalid_Name_With_Custom_Order()
        {
            Assert.Throws<InvalidOperationException>(() =>
            {
                Assert.Equal(1, _customOrderDataReader.GetOrdinal("ABC123XYZ_foobar_bad_name"));
            });
        }

        [Fact]
        public void IsDbNull_Returns_Correct_Value()
        {
            Assert.True(_dataReader.IsDBNull(1));
        }

        [Fact]
        public void IsDbNull_Returns_Correct_Value_With_Custom_Order()
        {
            Assert.True(_customOrderDataReader.IsDBNull(1));
        }

        [Fact]
        public async Task GetValue_Returns_Correct_Value()
        {
            var element = await _enumerable.ElementAtAsync(0);
            element.Id = 418;
            element.Name = "Michael";

            Assert.Equal(418, _dataReader.GetValue(0));
            Assert.Equal("Michael", _dataReader.GetValue(1));
        }

        [Fact]
        public async Task GetValue_Returns_Correct_Value_With_Custom_Order()
        {
            var element = await _customOrderEnumerable.ElementAtAsync(0);
            element.Id = 11;
            element.FirstName = "Edgar";
            element.MiddleName = "Allan";
            element.LastName = "Poe";

            // We look up the values from the source entity using the source ordinals (i.e., the position
            //   of the properties as declared on the entity, NOT via ColumnAttribute).
            Assert.Equal(11, _customOrderDataReader.GetValue(0));
            Assert.Equal("Edgar", _customOrderDataReader.GetValue(1));
            Assert.Equal("Allan", _customOrderDataReader.GetValue(2));
            Assert.Equal("Poe", _customOrderDataReader.GetValue(3));
            Assert.Null(_customOrderDataReader.GetValue(4));
        }

        [Fact]
        public async Task GetBytes_Returns_Correct_Value()
        {
            var inputBytes = Encoding.UTF8.GetBytes("Michael");

            var element = await _enumerable.ElementAtAsync(0);
            element.Id = 419;
            element.Data = inputBytes;

            var buffer = new byte[128];
            const int fieldOffset = 0;
            const int bufferOffset = 10;
            var bytesRead = _dataReader.GetBytes(2, fieldOffset, buffer, bufferOffset, buffer.Length - bufferOffset);

            Assert.Equal(bytesRead, inputBytes.Length);
            Assert.Equal("Michael", Encoding.UTF8.GetString(buffer, bufferOffset, (int)bytesRead));
        }

        [Fact]
        public async Task GetBytes_Returns_Correct_Value_Equal_Buffer()
        {
            var element = await _enumerable.ElementAtAsync(0);
            element.Data = new byte[16];
            new Random().NextBytes(element.Data);

            var buffer = new byte[16];
            var count = _dataReader.GetBytes(2, 0, buffer, 0, 0);

            Assert.Equal(16, count);
            Assert.Equal(element.Data, buffer);
        }

        [Fact]
        public async Task GetBytes_Returns_Correct_Value_Less_Than_Buffer()
        {
            var element = await _enumerable.ElementAtAsync(0);
            element.Data = new byte[16];
            new Random().NextBytes(element.Data);

            var buffer = new byte[32];
            var count = _dataReader.GetBytes(2, 0, buffer, 0, 0);

            Assert.Equal(16, count);
            Assert.Equal(element.Data, buffer.Take(16));
            Assert.True(buffer.Skip(16).Take(16).All(b => b == 0));
        }

        [Fact]
        public async Task GetBytes_Returns_Correct_Value_Greater_Than_Buffer_Partial_Page()
        {
            var element = await _enumerable.ElementAtAsync(0);
            element.Data = new byte[24];
            new Random().NextBytes(element.Data);

            var buffer = new byte[16];
            var result = new byte[24];
            var count = ByteReadHelper(2, buffer, result);

            Assert.Equal(24, count);
            Assert.Equal(element.Data, result);
        }

        [Fact]
        public async Task GetBytes_Returns_Correct_Value_Greater_Than_Buffer_Multiple_Full_Pages()
        {
            var element = await _enumerable.ElementAtAsync(0);
            element.Data = new byte[16 * 3];
            new Random().NextBytes(element.Data);

            var buffer = new byte[16];
            var result = new byte[16 * 3];
            var count = ByteReadHelper(2, buffer, result);

            Assert.Equal(16 * 3, count);
            Assert.Equal(element.Data, result);
        }

        [Fact]
        public async Task GetBytes_Returns_Correct_Value_Empty()
        {
            var element = await _enumerable.ElementAtAsync(0);
            element.Data = new byte[0];
            new Random().NextBytes(element.Data);

            var buffer = new byte[16];
            var result = new byte[0];
            var count = ByteReadHelper(2, buffer, result);

            Assert.Equal(0, count);
            Assert.Equal(element.Data, result);
        }

        [Fact]
        public async Task GetBytes_Returns_Correct_Value_Default_BulkCopy_Buffer()
        {
            var element = await _enumerable.ElementAtAsync(0);
            element.Data = Guid.NewGuid().ToByteArray();

            var buffer = new byte[4096];
            var result = new byte[element.Data.Length];
            var count = ByteReadHelper(2, buffer, result);

            Assert.Equal(element.Data.Length, count);
            Assert.Equal(element.Data, result);
        }

        private long ByteReadHelper(int ordinal, byte[] buffer, byte[] result)
        {
            long count;
            long offset = 0;
            do
            {
                count = _dataReader.GetBytes(ordinal, offset, buffer, 0, 0);
                Buffer.BlockCopy(buffer, 0, result, (int)offset, (int)count);
                offset += count;
            } while (count == buffer.Length);
            return offset;
        }

        [Fact]
        public async Task GetBytes_Returns_Correct_Value_With_Custom_Order()
        {
            var inputBytes = Encoding.UTF8.GetBytes("Edgar");

            var element = await _customOrderEnumerable.ElementAtAsync(0);
            element.Id = 12;
            element.Data = inputBytes;

            var buffer = new byte[128];
            const int fieldOffset = 0;
            const int bufferOffset = 10;

            // When reading values from the source object, we use the property's positional ordinal.
            var bytesRead = _customOrderDataReader.GetBytes(4, fieldOffset, buffer, bufferOffset, buffer.Length - bufferOffset);

            Assert.Equal(bytesRead, inputBytes.Length);
            Assert.Equal("Edgar", Encoding.UTF8.GetString(buffer, bufferOffset, (int)bytesRead));
        }

        [Fact]
        public void GetName_Returns_Correct_Value()
        {
            Assert.Equal(nameof(MyTestClass.Id), _dataReader.GetName(0));
            Assert.Equal(nameof(MyTestClass.Name), _dataReader.GetName(1));
        }

        [Fact]
        public void GetName_Returns_Correct_Value_With_Custom_Order()
        {
            // GetName returns the source property's name. We use the source property's positional
            //   ordinal to look that up.
            Assert.Equal(nameof(MyCustomOrderTestClass.Id), _customOrderDataReader.GetName(0));
            Assert.Equal(nameof(MyCustomOrderTestClass.FirstName), _customOrderDataReader.GetName(1));
            Assert.Equal(nameof(MyCustomOrderTestClass.MiddleName), _customOrderDataReader.GetName(2));
            Assert.Equal(nameof(MyCustomOrderTestClass.LastName), _customOrderDataReader.GetName(3));
            Assert.Equal(nameof(MyCustomOrderTestClass.Data), _customOrderDataReader.GetName(4));
        }

        [Fact]
        public void FieldCount_Returns_Correct_Value()
        {
            Assert.Equal(3, _dataReader.FieldCount);
        }

        [Fact]
        public void FieldCount_Returns_Correct_Value_With_Custom_Order()
        {
            Assert.Equal(5, _customOrderDataReader.FieldCount);
        }

        public class MyTestClass
        {
            public int Id { get; set; }

            public string Name { get; set; }

            public byte[] Data { get; set; }
        }

        /// <summary>
        /// For testing property mapping where property layout doesn't match the database table's ordinals.
        /// </summary>
        public class MyCustomOrderTestClass
        {
            [Column(Order = 0)]
            public int Id { get; set; }

            [Column(Order = 4)]
            public string FirstName { get; set; }

            [Column(Order = 1)]
            public string MiddleName { get; set; }

            [Column(Order = 2)]
            public string LastName { get; set; }

            [Column(Order = 3)]
            public byte[] Data { get; set; }
        }

        public async Task InitializeAsync()
        {
            await _dataReader.ReadAsync();
            await _customOrderDataReader.ReadAsync();
        }

        public Task DisposeAsync()
        {
            _fixture.ExecuteNonQuery(_connectionString, "DROP TABLE " + _tableName);
            _fixture.ExecuteNonQuery(_connectionString, "DROP TABLE " + _customOrderTableName);

            return Task.CompletedTask;
        }
    }
}
